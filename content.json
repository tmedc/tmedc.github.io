{"meta":{"title":"Tmedc's Notes","subtitle":"Learning","description":null,"author":"tmedc","url":"https://tmedc.github.io"},"pages":[{"title":"Tags","date":"2018-10-10T07:33:13.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"tags/index.html","permalink":"https://tmedc.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-10-10T07:33:05.000Z","updated":"2019-01-04T02:41:58.028Z","comments":true,"path":"about/index.html","permalink":"https://tmedc.github.io/about/index.html","excerpt":"","text":"Email：dynamicers@163.com"},{"title":"Categories","date":"2018-10-10T07:26:21.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"categories/index.html","permalink":"https://tmedc.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python数字、字符串、字节串相互转换","slug":"Python数字、字符串、字节串相互转换","date":"2019-01-02T02:37:57.000Z","updated":"2019-01-08T12:12:11.164Z","comments":true,"path":"2019/01/02/Python数字、字符串、字节串相互转换/","link":"","permalink":"https://tmedc.github.io/2019/01/02/Python数字、字符串、字节串相互转换/","excerpt":"","text":"近期用到了一些有关Python字节串的内容，整理一下相关数据类型之间的转换方法。 一.整型数据向其他类型的转换以下代码中a为int类型 整型 进制转换：转换后就变成了字符串！！！ 输出时进制转换：print(&quot;%#x&quot;%a) 或者 print(&quot;%#o&quot;%a) 浮点型 隐式转换 或者float(a) 字符串 直接转换：str(a) 改变进制：hex(a) ， oct(a) 数字到单个ASCII字符转换：chr(a) 字节串 bytes([a, a1, a2])（解释：将需要转换的整型数字放入list中，再传给bytes()函数，如果直接将整型数字N传过去，会返回N个空字节。 12345# 10进制数组直接转换:bytes([1,2,3]) ==&gt; b'\\x01\\x02\\x03' # 16进制数组直接转换:bytes([0x01,0x02,0x31,0x32]) ==&gt; b'\\x01\\x0212' a.to_bytes(len, byteorder=&#39;big&#39;/&#39;little&#39;, signed=True/False)其中len为转换后的字节串长度 12345678import structstruct.pack('B'/'&lt;H'/'&gt;H', a) # 第一个参数是格式字符串，指定了字节格式的长度，字节顺序等# 转为两个字节: struct.pack('&lt;HH', 1,2) ==&gt; b'\\x01\\x00\\x02\\x00'# 转为四个字节:struct.pack('&lt;LL', 1,2) ==&gt; b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00' 二、浮点型向其他类型的转换以下代码中f为float类型 整型 取整：int(f) 四舍六入五成双：round(f) 注意: round()函数可以接收第二个参数调整舍入的位置，默认为1，如果是-1则舍入十位，如果是2则舍入百分位 字符串 str(f) 三、字符串向其他类型的转换以下代码中s为字符串类型 整型 十进制字符串转为int：int(s) N进制字符串转为int：int(s, N) 二进制字符串转为int：int(s, 2) 八进制字符串转为int：int(s,8) 十六进制字符串转为int：int(s, 16) ​ 单个字符转换为ASCII序号：ord(s) 浮点型 float(s) 字节串 在这里先介绍在Python3中str和bytes类型的区别，两种类型都用来表示字符序列，str包含的是Unicode字符，bytes包含的是原始的8位值。从原始二进制数据到Unicode（或者任意一种编码方式）字符的过程叫做decode，从字符到二进制数据的过程叫做encode。 12345678# 普通字符串encode方式:'123abc'.encode('ascii') ==&gt; b'123abc' # 16进制字符串转换方式:bytes().fromhex('010210') ==&gt; b'\\x01\\x02\\x10'# 16进制字符串先转换为int再转为字节串:bytes(map(ord, '\\x01\\x02\\x31\\x32')) ==&gt; b'\\x01\\x0212' 四、字节串向其他类型的转换以下代码中b为字节串类型 整型 12345678import struct# 转义为short型整数: struct.unpack('&lt;hh', bytes(b'\\x01\\x00\\x00\\x00')) ==&gt; (1, 0)struct.unpack('&lt;hh', b'\\x01\\x00\\x00\\x00') ==&gt; (1, 0)# 转义为long型整数: struct.unpack('&lt;L', bytes(b'\\x01\\x00\\x00\\x00')) ==&gt; (1,) 字符串 12345# 字节码解码为字符串:bytes(b'\\x31\\x32\\x61\\x62').decode('ascii') ==&gt; 12ab# 字节串转为16进制字符串数组[hex(x) for x in bytes(b'\\x01\\x0212')] ==&gt; ['0x1', '0x2', '0x31', '0x32'] 附：字节数组字节串和字符串一样是不可变序列，字节数组就是可变版本的字节，类似与list与tuple 1234567bytearray(b'hello') ==&gt; bytearray(b'hello')bytearray() ==&gt; bytearray(b'')bytearray([1,2,3]) ==&gt; bytearray(b'\\x01\\x02\\x03')bytearray('runoob', 'utf-8') ==&gt; bytearray(b'runoob')","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://tmedc.github.io/tags/Python/"}]},{"title":"Ubuntu16.04下配置Docker+GPU+TensorFlow+Pycharm开发环境","slug":"Ubuntu16-04下配置Docker-GPU-TensorFlow-Pycharm开发环境","date":"2018-12-21T02:35:14.000Z","updated":"2019-01-14T11:43:36.992Z","comments":true,"path":"2018/12/21/Ubuntu16-04下配置Docker-GPU-TensorFlow-Pycharm开发环境/","link":"","permalink":"https://tmedc.github.io/2018/12/21/Ubuntu16-04下配置Docker-GPU-TensorFlow-Pycharm开发环境/","excerpt":"","text":"1.安装NVIDIA显卡驱动介绍两种方法： 1.官网下载驱动文件，手动安装 去NVIDIA官网下载安装包，选择适配自己硬件的版本，然后本地安装（运行下载的runfile文件，运行时需要一些额外的参数，以及一些其他的操作） https://www.nvidia.com/Download/index.aspx?lang=en-us 注意：使用该方法在安装显卡驱动过程中，可能存在一些问题，我尝试几次之后还是失败 2.PPA源安装 方法十分简便，添加ppa源后，在system settings -&gt; Software &amp; Updates -&gt; Additional Drivers 中选择相应驱动即可。（据传该方法未必会有最新驱动，或者可能遇到问题，我运气比较好成功安装了） 添加ppa源的命令如下: 123sudo add-apt-repository ppa:xorg-edgers/ppa #添加ppa源sudo add-apt-repository ppa:graphics-drivers/ppa #添加ppa源sudo apt-get update #更新apt-get 2. 安装Docker同样有两种方式可以安装 1.ppa方式安装，但是速度太慢 https://docs.docker.com/install/linux/linux-postinstall/ 按照提示操作即可 2.可以选择deb包安装，可以在清华镜像源下载 https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ 找到适合自己的版本后，需要依次安装 container.io、 docker-ce-cli、docker-ce 3.安装NVIDIA-dockergtihub地址：https://github.com/NVIDIA/nvidia-docker 按照提示操作即可 4.pull TensorFlow Docker image123docker pull tensorflow/tensorflow # latest stable releasedocker pull tensorflow/tensorflow:devel-gpu # nightly dev release w/ GPU supportdocker pull tensorflow/tensorflow:latest-gpu-jupyter # latest release w/ GPU support and Jupyter 参考地址：https://www.tensorflow.org/install/docker 然后就可以run TensorFlow Docker image就可以了 5.配置Pycharm完成上述操作后，可以在终端进行开发，为了在IDE中开发，需要使用Pycharm Professional（社区版没有Docker插件） 在Pycharm中需要完成以下操作： 提前准备工作：把用户添加到Docker用户组中：sudo usermod -aG docker UserName,如果不进行这一步，在后面Pycharm连接docker时会提示权限不够。 “File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Docker” 添加 Docker， 并选择”Unix Socket“ “File -&gt; Settings -&gt; Project -&gt; Project Interpreter” 添加新的Interpreter，选择 Docker类型，并选择对应的image到此为止，已经成功添加Docker中的TensorFlow为解释器，但是此时如果运行，程序会提示无法找到脚本文件，下面要进行配置过程中最为关键的两步：1.挂载host目录到container中：在“File -&gt; Settings -&gt; Project -&gt; Project Interpreter”中， 添加“Path mapping”：“ -&gt; /opt/project”完成这一步后，运行代码，会提示无法找到libcuda.so.1的库，这是因为Pycharm默认使用的是docker而不是nvidia-docker，所以要进行下一步操作更改nvidia-docker为默认的docker2.把&quot;default-runtime&quot;: &quot;nvidia&quot;,添加到/etc/docker/daemon.json文件中123456789&#123; &quot;default-runtime&quot;:&quot;nvidia&quot;, &quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125;&#125; 然后要重启docker的守护进程：sudo pkill -SIGHUP dockerd,这样以来刚刚更改的配置就生效了，可以在Pycharm中正常run脚本了。 6.在TensorFlow image中导入新的库在docker中，所有在container中进行的更改都不会影响image，所以如果想在image中导入新的库，需要在container中下载新的库之后，commit之后才能保存在image中，后续在继续更新具体操作方法 7.其余常见问题 Ubuntu切换显卡问题，当使用的显卡是Intel的集成显卡时，运行GPU版的TensorFlow会报错，此时需要把显卡切换为NVIDIA显卡。在安装nvidia-prime后，在终端执行以下命令sudo prime-select nvidia，注销后重新登录即可切换为NVIDIA显卡。 8.附录一个超级详细、非常清晰、极其牛逼的docker教程","categories":[{"name":"Environment Configuration","slug":"Environment-Configuration","permalink":"https://tmedc.github.io/categories/Environment-Configuration/"}],"tags":[{"name":"TF","slug":"TF","permalink":"https://tmedc.github.io/tags/TF/"},{"name":"Docker","slug":"Docker","permalink":"https://tmedc.github.io/tags/Docker/"}]},{"title":"平均与均摊时间复杂度","slug":"平均与均摊时间复杂度","date":"2018-12-18T14:24:38.000Z","updated":"2018-12-18T14:28:31.737Z","comments":true,"path":"2018/12/18/平均与均摊时间复杂度/","link":"","permalink":"https://tmedc.github.io/2018/12/18/平均与均摊时间复杂度/","excerpt":"","text":"Amortized time complexity takes a mean over many iterations of the same operation. The bound may be exceeded for single operations, but not for a sustained period of operation. Average time complexity takes a mean over many possible inputs to a single operation. The bound may be exceeded for a few “hard” inputs, but not for a sufficiently large number of inputs.[1] 均摊时间复杂度和平均时间复杂度描述的层面不一样。 均摊时间复杂度针对该层面：同一操作被执行的第一次和第二次时，时间复杂度可能不一致，偶尔会出现高复杂度的情况，多次执行该操作，取复杂度均值，就是均摊时间复杂度。同时更多是针对某一个操作，而不是某一个算法。 平均时间复杂度针对该层面：同意操作被不同数据执行时，时间复杂度可能不一致，偶尔会出现高复杂度的数据，使用多个不同数据执行该操作，取复杂度均值，就是平均时间复杂度。多是针对某一个算法。 可能存在一些问题，后续有新的理解会继续更正。 reference：[1] https://www.quora.com/What-s-the-difference-between-average-time-complexity-and-amortized-time-complexity by Mark Gritter.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tmedc.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tmedc.github.io/tags/Algorithm/"}]},{"title":"10月9日面试","slug":"10月9日面试","date":"2018-10-09T11:50:02.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"2018/10/09/10月9日面试/","link":"","permalink":"https://tmedc.github.io/2018/10/09/10月9日面试/","excerpt":"","text":"概况前几天投了头条的推荐算法工程师实习生，这个岗位是属于懂车帝部门的。自己的简历实在过于简陋，一开始并没有想到能够拿到面试机会，9月27号接到HR面试通知，本来约了28号，后来心虚该到了十一之后，本来打算十一假期恶补，结果……不提了 今天下午两点的面试，整个面试过程大概40分钟左右，在一个休息厅里面，一对一面试，同时有很多人在面试，环境有点吵（我旁边就是一位面试销售岗或者运营岗的面试官，在我面试过程中，有两个疑似社招的大姐姐来面试，他们一直在讨论…） 面试题目可能因为简历上的项目过于简陋，面试官问的问题很基础： 问：你简历上有一个图像处理的项目，是用什么做的？为什么用CNN做图像处理，不用RNN、DNN？ 了解哪些机器学习模型？写一下sigmoid函数？推导一下Logistics回归的损失函数？损失函数和最大似然的区别（疑似，已经记不清了）？ logistics回归是线性模型还是非线性模型？线性模型和非线性模型的区别，你是怎么理解两者的？ 知道过拟合吗？怎么处理过拟合？知道正则化吗？ 手写代码：求字符串中最长回文子串的长度？ 最后问我有什么问题，我问如果想应聘这个岗位需要准备些啥，对我这次面试的评价。面试官尴尬得笑着说自然是准备地越多越好，这次面试的评价嘛，多做题，多参加些比赛什么的，实战经验很重要。然后就结束了，等HR通知，估计基本凉凉。 10月11日更新：正式邮件通知了，未通过面试。继续努力吧 感悟 基础知识还是太薄弱了，很多基础知识掌握不牢固 沟通能力亟待加强，前期沟通感觉不是很顺畅 加强算法数据结构基本功，提高代码能力，手写代码过程很僵硬，写了一版错误的动态规划，后面说了一个思路：先反转字符串，再KMP，面试官问会不会KMP，我尴尬地说忘记了… 提高机器学习实践经验","categories":[{"name":"Diary","slug":"Diary","permalink":"https://tmedc.github.io/categories/Diary/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://tmedc.github.io/tags/Interview/"}]},{"title":"Algorithm Note","slug":"Algorithm-Note","date":"2018-06-15T08:24:10.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"2018/06/15/Algorithm-Note/","link":"","permalink":"https://tmedc.github.io/2018/06/15/Algorithm-Note/","excerpt":"","text":"时间复杂度 时间复杂度表示的不是程序运行时间的长短，而是随着元素数量增加，程序运行时间的增长速度 常见的有log(n) n… 数组和链表 数组的查询方便 链表的增删、插入方便 递归 递归可以理解为函数将自己作为子函数，自己调用自己直到满足条件 递归使用时，分为基线条件和递归条件 快速排序 快速排序平均情况下时间复杂度为nlog(n), 最糟情况下时间复杂度为n^2 合并排序时间复杂度为nlog(n), 但是一般情况下要慢于快速排序 hash table 哈希表的应用可以：查找元素、防止重复、用作缓存(URL为键,网页数据为值) hash table要注意避开冲突，可以使用较低的填装因子、良好的散列函数 队列和栈 队列和栈类似, 队列是FIFO, 栈是LIFO 图和树 图是用边表示拓扑关系的网络图，分为有向图和无向图 树是一种特殊的图，没有往后指的边 广度优先搜索 用在非加权图的最短路径查找 狄克斯特拉算法 用在加权图的最短路径查找 只适用于有向无环图 存在负权边时,不再适用 字符串原码反码补码 对于正数而言，三者一样。首位符号位，0为正数，1为负数 对于负数而言，原码是符号位加上绝对值的码；反码是除去符号位外，其余对原码取反，解决了原码正负相加不为零的问题；补码是反码+1，也可以用高一位的正数比如10000类似这种减去绝对值的码，解决了反码两个0的问题 使用补码时，正数是0~127，负数是-1~-128 （以一字节为例） 转义字符 转义字符的符号是反斜杠 \\ ,回车上边这个 \\后边可以跟 a b f n r t v \\ ‘ “ ? 0 (?可能存在疑问) 还以直接跟数字 默认前三个按八进制处理 输出ASCII字符 (如果三个数字第一个是0,这个0就被忽略了,074和74的效果一样.无聊试了一下,最大可以接受777 ,如果是778 就会按77处理,输出一个?在输出8,这个777是十进制的511) 可以跟\\x和数字 默认前两个数字按十六进制处理 输出ASCII字符(只有小写x才对,大写X不会转义) 字符串匹配 KMP算法 next数组 nextval数组 哈夫曼编码 根据字母出现频率高低 前缀码 a为0-1序列（字符串），Q=｛a,a1,a2…}，如果Q中没有一个序列是另一个序列的前缀，则称Q为前缀码 组合数学卡特兰数 待解决。。。 树二叉树分类 满二叉树 完全二叉树 遍历 前序遍历 NLR 中序遍历 LNR 后序遍历 LRN","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tmedc.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tmedc.github.io/tags/Algorithm/"}]},{"title":"Regular Express Note","slug":"Regular-Express-Note","date":"2018-05-02T08:22:01.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"2018/05/02/Regular-Express-Note/","link":"","permalink":"https://tmedc.github.io/2018/05/02/Regular-Express-Note/","excerpt":"","text":"Meta-character位置 \\b 匹配字符串的开始或结束，boundary。 反义为\\B ^ 匹配字符串的开始, (选择处理多行后，表示行的开始) $ 匹配字符串的结束, (同上) 字符 . 匹配任意字符，除换行符 \\d 匹配数字。 反义为\\D \\w 匹配字母、数字、下划线、汉字。 反义为\\W \\s 匹配任意空白符。 反义为\\S 数量 * 前面的字符连续重复使用任意次，[0, +inf] + 连续重复至少一次，[1, +inf] ? 连续重复0或1次，[0,1] {n} 前面字符必须重复n次 {n,} 重复n或者更多次，[n, +inf] {n,m} 重复次数范围是[n,n] 转义符 匹配元字符本身时，需要使用\\转义符，比如匹配$, 需要\\$ /也需要使用转义符，即\\/的样子 []的使用 匹配abcd四个字母中任意一个时，使用[abcd], 类似的有\\d=[0-9], \\w=[a-z0-1A-Z] 分支条件 |表示用来分割不同规则，其中任意一个规则匹配即可，并且从左到右直到遇到第一个满足的匹配条件，后续的规则就不管了 反义 元字符的反义：把小写改为大写 []的反义：[^x]表示除x以外的任意字符 后向引用() 指定一个子表达式被捕获为一个分组，后续可以被\\1代替从而进行重复搜索，默认0为整个正则表达式，1维第一个，2 为第二个… 组号分配过程需扫描两次，第一次扫描未命名组，第二次扫描命名组，所以命名组的组号一定大于未命名组 捕获 (exp) 匹配exp并捕获文本到自动命名的组中 (?&lt;name&gt;exp) 或者(?&#39;name&#39;exp)匹配exp，并捕获到命名为name的组中, (?:exp) 匹配exp，但是不捕获，也不分配组号 零宽断言、负向零宽断言 零宽断言用于指定位置，作用和\\b、^、$类似 断言用来声明一个为真的事实，只有断言为真时，才会继续进行匹配 语法列表零宽断言： (?=exp) 匹配exp后面的位置。这个位置后面有exp。断言后缀是exp (?&lt;=exp) 匹配exp前面的位置。这个位置前面有exp。断言前缀是exp 负向零宽断言： (?!exp) 匹配后面不是exp的位置。这个位置后面没有exp。断言后缀不是exp (?&lt;!exp) 匹配前面不是exp的位置。这个位置前面没有exp。断言前缀不是exp 注释 不忽略空白符时：使用(?#comment) 来写注释 忽略空白符时： 和python注释规则一样，#后面直至行尾都被认为时注释 贪婪与懒惰 正则表达式在默认情况下，会尽可能匹配更长的字符串，称为“贪婪”。 在匹配条件后面加上?可以转为懒惰模式，尽可能使用最少的重复。例如：*? 匹配任意次，但尽可能少重复 比贪婪懒惰规则更高优先级的规则是：最先开始的的匹配拥有最高优先级，”The match that begins earliest wins.” 平衡组/递归匹配","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://tmedc.github.io/tags/RE/"}]},{"title":"Python Note","slug":"Python-Note","date":"2018-03-04T08:19:38.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"2018/03/04/Python-Note/","link":"","permalink":"https://tmedc.github.io/2018/03/04/Python-Note/","excerpt":"","text":"String1. 字符串变量常用方法 “+” 用于连接两个字符串 str.title() 、str.upper()、 str.lower() 大小写 不改变原字符串 str.strip()、 str.lstrip()、 str.rstrip() 删除空格 str.split() 分割字符串 str.find() 查找子串，返回第一个索引 没有找到返回-1 str.index() 与find类似，找不到引发异常 str.startswith() str.endswith() 返回bool值 str.isdigit() 检查是否由数字组成 str.isalpha检查是否由字母组成 str.isalnum检查是否由字母数字组成 返回bool值 str.join(sequence) 返回一个字符串，这个字符串是用str把sequence中元素连接起来。sequence必须是由字符元素组成的 str.count(&#39;s&#39;) 返回字符串中s字符的个数 字符串也有切片 和 list切片用法一样 使用切片时的index使用方法和range的index使用方法一样 注意: 加()和不加()区别很大，不加时为python的内置函数名，加上才是调用函数，才会返回字符串的处理结果。 ord(char) 把char按照ASCII转化为integer; 对应的chr(int) 把integer转化为char 2. 数字变量常用方法 + - * / **乘方、 //取整、 %取余 &amp; | ^ ~ 按位与 按位或 按位异或 按位取反 &lt;&lt; &gt;&gt; 左移 右移 int(str, 2) 输入为字符串，第二个参数为输入字符串采用的进制，默认为10；输出为10进制integer int(float) 可以直接向下取整；round(float) 四舍五入取整；math.ceil(float) 向上取整 bin(int) 输入为integer(不一定是10进制)， 输出为二进制形式的字符串，以0b开头 oct(int) 输入为integer(不一定是10进制)， 输出为八进制形式的字符串，以0o开头 hex(int) 输入为integer(不一定是10进制)， 输出为十六进制形式的字符串，以0x开头 List &amp; Tuple1. 列表 列表的访问 list[index] 添加 list.append(value) 合并另外一个list list.extend(list1) 插入 list.insert(index, value) 彻底删除 del list[index] 不返回删除值 弹出 list.pop(index/null) 返回删除值 删除第一个确定值 list.remove(value) 存在多个时，只删除一个；不返回删除值，返回None 永久排序 list.sort(null/ reverse=Ture) 在原有list上直接修改。对于字符串列表默认排序方式是按字母表，list.sort(key=len) 可以按照字符串长度排序 临时排序 sorted(list) 返回一个新的list 并不会改变原有list。附加参数和list.sort()一样，可以加reverse，可以加key 反转列表列表顺序 list.reverse() 列表长度 len(list) 列表的遍历 for 带索引的循环 for i, value in enumerate(listname)， enumerate 会把list变为索引-元素对 2. 数值列表 range(start_int, end_int+1, step_int) 配合 for 循环生成需要的数值列表 注意：setp_int 可以是负数 例如range(5, 0, -1) 转为list后为5 4 3 2 1 再注意： 当step_int 是负数的时候，前边两个必须是从大到小的；是正数的时候，前部两个必须是从小到大的，否则就会出来个寂寞，就是说会出来个屁，就是说会出来空的 再再注意： 使用切片的时候，上面的规则都是一样一样的 list() 可以把range() 强制转换为列表 min(list) max(list) sum(list) 列表解析 list = [f(value) for value in range()] 切片 list[start_index : end_index+1] 用于复制列表 3. 元组tuple 一般用于在整个程序周期内不变的列表，比列表简单，不能修改元素，可以重新对整个元组赋值 Dictionary &amp; Set1. 字典注意 dictionary的key必须是不可变对象，像list这种就不能作为key 字典的定义：dictionary = {&#39;key1&#39;:value, &#39;key2&#39;, value} 字典的访问：字典名+[‘键名’] 添加与修改：字典名+[‘键名’] = 值 一次性添加多个：dict.update(key1=value1, key2=value2) 没有那么好用，key_name最好是字符串，而且不用带&quot;&quot; 元素的删除： del dicitonary[&#39;key&#39;] 字典键-值对的排列顺序和添加顺序无关不同， 也不关心，只关心对应关系 字典的遍历： for key, v in dictionary.items()，items()方法返回字典的键值对列表 for key in dictionary.keys()，keys()方法返回字典的键列表；不使用任何方法时，默认遍历键 for value in dictionary.values()，values()方法返回字典的值列表，提取出所有的值，会重复，用set()剔除重复项 字典的一些方法： in 判断key是否存在于dictionary中， dict.get(&#39;key_name&#39;, -1) dictionary提供了get方法，判断key是否存在于dictionary中，不存在时返回None, 可以自己指定返回值， 此例中指定为-1， 如果返回None就可以的话 省略第二个参数即可 dict.pop(key_name) 删除一个key，同时删除对应的value。和get方法一样可以加默认值，不存在时就返回该默认值，否则就会生成Key Error dict.popitem() 删除并返回一对键值对，字典为空的时候会引发 Key Error；删除的顺序可能比较随机 dict.clear() 清空字典 和list对比： 查找和插入极快且为O(1)时间复杂度，但是需要占用大量内存 ；list特性与之相反 2. 字典列表 以字典作为列表的元素，可以使用切片修改列表中的字典。 注意： 列表使用切片后，若在等号右侧，则会直接改变原列表 (这一条我已经看不懂了…可能是在循环中修改列表时，不能直接for i in list 需要 for i in list[:] 可能是这样吧，好像也不对… 2018.5.3注) 3. 字典中嵌套列表 用列表作为字典的值，来实现一个键对应多个值注意： 字典和列表的嵌套等级不应该太多 4. 字典中嵌套字典 这样会使代码变得复杂，尽量保证内部字典中键值一致 5. 集合 set 和 dictionary 类似，也是一组key的集合，但是不存储value。由于key不能重复，所以在set中没有重复的key。 注意 set和dictionary的唯一区别在于set没有存储value，二者的原理是一样的，都不能放入可变对象(因为无法判断两个可变对象是否相等，无法保证没有重复元素) 再注意 tuple作为不可变对象，当tuple中不包含不可变对象时，可以做key，否则不行。例如(1, 2)可以，(1, [1, 2])不可以 set的创建：需要提供一个list或者string(生成的set元素会是单个字符)作为输入，例如s = set([1, 2, 3]) 或者s = {1, 2, 3} 注意: 集合是无序的 也无法使用数字索引 set的方法： set1.add(key) 添加元素 set1.update(list) 一次性添加多个元素 set1.pop() 删除并返回一个元素，有一定随机性；若set1为空，则引发Key Error set1.remove(key) 删除元素 如果不存在会引发Key Error；set1.discard(key) 如果存在就会删除 set1.clear() 清空set set1 &amp; set2 取交集 set1 | set2 取并集 set1 - set2 取差集： 在set1中不在set2 中 set1 ^ set2 对称差集：在set1 或set2 中 ，但不会同时出现在两者中（即，两者各自特有的元素） set1 &lt;= set2 判断set1 是否为 set2 的子集 set1 &gt;=set2 判断set1 是否为 set2 的超集 len(set1) set1的长度 x in set1 x not in set1 None &amp; False Is &amp; == 在python中 None, False, 空字符串&quot;&quot;, 0, 空列表[], 空字典{}, 空元组()都相当于False if &amp; for &amp; while1. if语句的使用 and、or 连接表达式时无需括号 in、not in 用于判断列表中是否有该元素 可以适当使用elif来代替else if-elif-else 用来执行一个代码块，多个并列if用来执行多个代码块 把列表名用在if语句中时，若列表为空，返回False，否则为True 2. While循环 While循环中如果存在多个条件，程序才可以执行，可以设置标志，仅对标志进行判断即可 break和continue的区别 for循环适用于遍历列表，而while循环适合修改列表 3. for-else &amp; while-else 当for 或者 while代码块被完整执行时， else块才会被执行 用途： 在循环结束仍为找到目标值时， 生成错误： 12345for i in range(5): if i == 5: breakelse: print('not find 5') 用于跳出多层循环（也可以写成函数，使用return跳出多层循环） 123456789for condition1: for condition2: if condition3: do something else: break else: continue break 也就是说在多层循环中，最内层的break是无法跳出外层循环的。如果要跳出外层循环，必须对外层循环的每一层都加上以下代码： 12345for ... ...else: continuebreak Input &amp; Output1. 用户输入 input()函数得到的输入默认情况下是字符串，如果需要使用数字，需要类型转换 Function &amp; Module1. 函数 实参的传递方式包括：位置实参、关键字实参、默认值 一个函数尽量完成一个工作 传递任意数量的实参时，在函数定义中使用 *name ，其中name 是一个空元组tuple 传递任意数量的关键字实参时，在定义函数中使用 **name ，其中name是一个空的字典 2. 模块 模块就是一个包含代码块的独立文件，可以import file_name导入，注意不包含文件后缀名 使用模块内函数的格式为module_name.function_name() 只导入函数的格式为from module import function 导入所有函数from module import * 不推荐这样使用，可能引起函数名或变量名的冲突 3. 函数和模块的格式 函数和模块命名使用小写字母和下划线，要有意义 函数定义后要紧跟文档字符串，描述函数名称、实参、返回值 函数括号中=两侧不加空格，形参、实参都是如此 使用两个空行分割相邻函数 函数定义行需要换行时，下一行使用两个tab缩进 Variable &amp; Class1. 变量作用域 变量作用域包括内置作用域、全局作用域、嵌套作用域、局部作用域 gloabl用于在局部函数中声明变量是全局变量，将会在全局作用域中搜索改变量，如果没有搜到则在生成该变量时，把变量生成在全局作用域 nolocal用于在局部函数中声明变量是嵌套作用域的变量，用法和gloabl一致 2. 类 通常类的首字母大写，实例则是小写的 为类设置默认属性，不需要在定义中列出形参 修改属性时，可以直接访问实例属性进行修改、添加可以修改属性的方法 子类定义： 123class name(super_name) def __inti__(self, params..) super().__inti__(params..) 子类中定义同名函数可以覆盖父类函数 对象可以作为类中属性 导入模块中类的方式和导入模块中函数的方法类似。需要导入模块中多个类时，最好直接导入整个模块。 类的命名使用驼峰法，首字母大写，不加下划线。对象实例和模块名都是用小写格式 类中一个空行分隔方法。两个空行分隔类 先导入标准库，空一行再导入自己的模块 Open File &amp; Close File1. 读取文件 打开文件： 不适用文件后会自动关闭，不需要手动调用close() 12with open(&apos;file_name&apos;) as file_obj: pass 读取整个文件：file_obj.read() 该方法返回字符串，并且在结尾多一个空字符。 逐行读取文件： 123with open(&apos;file_name&apos;) as file_obj: for line in file_obj: pass 将文件内容存在列表中： 12with open(&apos;file_name&apos;) as file_obj: lines = file_obj.readlines() 2. 写入文件 在open() 函数中添加额外的参数，默认只读w 写入模式，会先清空原有内容r 读取模式a 附加模式r+ 读取写入模式 使用file_obj.write(&#39;str&#39;)方法写入字符串，注意只能写入字符串格式 Try - Except - Else1. 处理异常 使用try-except-else处理异常： 123456try: the codes may have bugsexcept Error_name: do when codes have bugselse: do when codes have no bugs 处理异常的优势在于可以使程序出错之后继续运行，同时反馈的是可控的内容，而不是traceback Save Data with json1. 存储数据 使用json来存储数据： 123import jsonjson.dump(data, file_obj)json.load(file_obj) Refactoring1. 代码重构 代码重构就是把一个复杂函数的功能提取出来，分别用功能更加具体的函数实现 Test1. 测试 测试代码的格式： 1234567891011import unittestfrom your_file import your_functionclass YourFunTest(unittest.TestCase): &quot;&quot;&quot;必须继承unittest.TestCase&quot;&quot;&quot; def test_your_func(self): &quot;&quot;&quot;必须以test开头&quot;&quot;&quot; result = your_funciton(param) self.assertEqual(result, expected result)unittest.main() 测试类：测试类的格式和测试普通函数的格式类似，可以使用 123def setUp(self): &quot;&quot;&quot;在这里创建一个被测实例，以及测试所需的其他数据，供整个类调用&quot;&quot;&quot; pass unittest中其他断言方法： b)``` 12345```assertNotEqual(a, b)``` ```assertIn(item, list)``` ```assertNotIn(item, list)``` ```assertTrue(x)``` ```assertFalse(x) 项目实践1.项目规划 开发大型项目时，先做好规划十分重要，要分析最终需求，并把需求按阶段划分、实现 2.技巧 for循环中不能修改列表，需要在其中修改列表时，可以使用列表副本设置循环，在循环内修改原列表 在python中将输出写入终端花费时间很长，甚至超过在游戏窗口绘制图形 python学习中发现的坑函数对传过来的实参处理方式 如果传过来的实参是一个变量，那么运行函数不能修改原变量 如果传过来的实参是一个对象，那么运行函数会修改原对象 python进阶高级特性列表生成式 List Comprehensions 可以把for和if语句写到列表生成语句中 1alist = [x * x for x in range(0, 5) if x % 2 ==0] 生成器 Generator 和列表生成式相比把[]改成() 1g = (x * x for x in range(0, 5)) 如果要生成generator的下一个值，需要调用next(g)或者使用for循环 如果在一个函数中，把return变成了yield，函数就不再是一个普通函数，而是一个generator generator在执行时，遇到yield就会返回，下次执行从此处继续开始 迭代器 Iterator 凡是可以作用于for循环的都是iterable 凡是可以作用于next()的都是iterator 集合数据类型如list、dict、str、等是iterable不是iterator，可以通过iter()获得一个iterator对象 函数式编程高阶函数 High-order-function 变量可以指向函数，函数名本身也是变量 将函数作为参数的函数叫做高阶函数 map()传入一个函数、一个iterable，返回一个iterator，对iterable中每一个元素用函数进行处理 reduce()传入参数和map类似，但是函数需要两个参数，其运行结果为f(f(x1, x2), x3)... filter()传入的参数和map类似，函数依次作用于序列中元素，根据返回的布尔值决定是否保留改元素，实现筛选功能。同样返回iterator sorted()也是一个高阶函数，可以传入key=fun函数实现自定义的排序，可以传入reverse=True实现反序 返回函数 将函数作为返回值的函数。在外部函数体内定义一个内部函数，并将其作为返回值返回 多次调用同一返回函数，返回的函数是不同的，即时调用时传入的参数一致 闭包Closure 就是指内部函数可以引用外部函数的参数和局部变量 返回的函数不会立即执行，当再次被调用时，才会执行 正是由于返回的函数不会立即执行，所以在返回闭包时返回函数不要引用任何循环变量或者后续会变化的变量。一定要引用循环变量时，需要再创建一个函数，使其绑定变量当前值。 匿名函数 lambda x, y: x * y 匿名函数没有函数名无需担心函数名冲突，同时匿名函数也是一个函数对象，可以赋值给变量，或者作为函数的参数、返回值 装饰器 Decorator 本质上Decorator是一个返回函数的高阶函数，当需要增强函数功能又不想修改函数定义时使用 使用Python的@语法，@decorator_name放在被装饰的函数定义前一行 传入参数的Decorator：需要编写一个返回Decorator的高阶函数 为了保证原始函数的__name__属性不被改变，需要在最内层的Decorator中第一行添加如下代码： 123import functools--snip--@functools.wraps(func) 偏函数 Partial function 当函数参数太多时，使用functools.partial可以建立一个新的函数，固定部分参数，在调用时更简单 创建偏函数时，可以接收函数对象、*args、**kw这3个参数 传递可变参数 *args表示可以接收非关键字参数，即tuple类 **kw表示可以接收关键字参数，即dict类","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://tmedc.github.io/tags/Python/"}]},{"title":"指针相关笔记","slug":"指针相关笔记","date":"2017-11-18T10:40:30.000Z","updated":"2019-01-18T10:52:48.175Z","comments":true,"path":"2017/11/18/指针相关笔记/","link":"","permalink":"https://tmedc.github.io/2017/11/18/指针相关笔记/","excerpt":"","text":"1234567891011int *p; // int型指针int **p; // 二级指针，指向int型指针int *p[5]; // int型指针数组，长度为5int (*p)[5]; // 数组指针，指向的数组为5长度的int型数组int (*p) (int a, int b); // 函数指针，指向的函数返回值为int型，参数列表和后面声明一致int *fun(int a, int b); // 函数，返回值为int型指针int (*p[5]) (int a, int b); // 函数指针数组，数组长度为5，指向的函数类型如声明所示struct mystru *p; // 结构体指针，指向结构体mystu","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"C","slug":"C","permalink":"https://tmedc.github.io/tags/C/"}]},{"title":"Matlab使用笔记","slug":"Matlab使用笔记","date":"2017-10-18T13:26:12.000Z","updated":"2018-12-18T14:16:10.167Z","comments":true,"path":"2017/10/18/Matlab使用笔记/","link":"","permalink":"https://tmedc.github.io/2017/10/18/Matlab使用笔记/","excerpt":"","text":"自动对齐全选之后，使用ctrl+i 可以自动对齐代码块 figure窗口最大化figure; set(gcf,&apos;outerposition&apos;,get(0,&apos;screensize&apos;)); 文件打开对话框函数uigetfile[fname, fpath] = uigetfile(... {&apos;*.txt&apos;, &apos;*.*&apos;}, ... &apos;Pick a file&apos;); a = load(fullfile(fpath, fname)); 数据太长转下行一行末尾加...即可敲回车换行后继续输入本行内容","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://tmedc.github.io/tags/Matlab/"}]},{"title":"对C语言头文件的一些认识","slug":"对c语言头文件的一些认识","date":"2017-09-19T14:43:05.000Z","updated":"2019-01-18T10:41:36.540Z","comments":true,"path":"2017/09/19/对c语言头文件的一些认识/","link":"","permalink":"https://tmedc.github.io/2017/09/19/对c语言头文件的一些认识/","excerpt":"","text":"在编写程序过程中，对c语言中同名的.h文件和.c文件之间的关系产生了一些疑惑，二者之间是什么关系呢？随后进行了查阅，有一些收获，总结如下： .h文件和.c文件对于编译器而言没有任何区别。 同名的.h文件和.c文件之间不存在绑定关系，只是遵从习惯通常在.h文件中声明.c文件中的函数，当这些函数被其他文件调用时方便声明。有时，在c文件的开头也会包含同名的h文件，其作用就是在文件开头声明了本文件中的所有函数，在某些工程中被要求为规范写法。 c文件中的#include&quot;xx.h&quot;语句表明的含义就是告诉编译器在预编译过程中用该.h文件中的全部内容替换该语句。同时.h文件不指示任何库文件（中间目标文件的集合）的存储位置，所有库应放在默认目录或指定目录下。 一般来说编译器主要有一下三个工作过程：预编译、编译、链接。预编译过程负责处理各种宏定义、文件包含和条件编译；编译过程检查各个源文件的语法是否正确，函数和变量有没有声明，不用考虑函数的具体实现，语法检查通过之后就会生成中间目标文件（.o文件或.obj文件）；链接过程编译器将会遍历所有的中间目标文件去查找相应函数的具体实现，如果不能找到函数的具体实现或者函数存在多次实现都会报错。 链接分为动态链接和静态链接，静态链接使用的静态链接库（.a或.lib文件）生成的二进制代码将被包含在可执行文件中，静态链接生成的可执行文件可以独立运行；动态链接使用的动态链接库（.so或dll文件）只会被可执行文件引用而不会被包含，生成的可执行文件一般无法独立运行。 同一个h文件为了避免被同一个c文件多次包含可以采用如下代码格式： 1234#ifndef _XX_H#define _XX_H...#endif","categories":[{"name":"Programing Language","slug":"Programing-Language","permalink":"https://tmedc.github.io/categories/Programing-Language/"}],"tags":[{"name":"C","slug":"C","permalink":"https://tmedc.github.io/tags/C/"}]}]}